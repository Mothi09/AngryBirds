<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Angry Birds — Lite</title>
<style>
  :root{
    --bg:#f0f4f8;
    --box:#ffffff;
    --accent:#f76d99;
    --muted:#6b7280;
    --shadow: 0 8px 24px rgba(16,24,40,0.08);
  }

  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg,#e9f0ff 0%,var(--bg) 100%);
    padding:24px;
  }

  .game-card{
    width:900px;
    max-width:98vw;
    background:var(--box);
    border-radius:14px;
    box-shadow:var(--shadow);
    padding:18px;
    display:grid;
    grid-template-columns: 1fr 260px;
    gap:12px;
  }

  /* Left area: canvas */
  .stage{
    background:linear-gradient(#bfe0ff, #eaf6ff);
    border-radius:10px;
    padding:12px;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  canvas{
    border-radius:8px;
    background:linear-gradient(180deg,#9ed0ff 0%, #7cc8ff 100%);
    box-shadow: inset 0 -30px 70px rgba(0,0,0,0.08);
  }

  /* Right area: controls */
  .panel{
    padding:8px 12px;
    display:flex;
    flex-direction:column;
    gap:10px;
    height:100%;
  }

  .header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }

  .title{
    font-weight:700;
    font-size:16px;
  }

  .muted { color:var(--muted); font-size:13px; }

  .stat{
    background:#fbfbff;
    border-radius:8px;
    padding:8px;
    box-shadow: 0 6px 18px rgba(16,24,40,0.04);
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-weight:600;
  }

  button{
    background:var(--accent);
    color:white;
    border:0;
    padding:10px 12px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
    box-shadow: 0 8px 18px rgba(247,109,153,0.18);
  }
  button.secondary{
    background:#eef2ff;color:#111827;box-shadow:none;font-weight:600;
  }

  .controls{display:grid;gap:8px}

  .hint{
    font-size:13px;color:var(--muted);
    padding:6px 8px;border-radius:8px;background:#fbfbff;
  }

  .footer{
    margin-top:auto;
    font-size:12px;color:var(--muted);
    text-align:center;
  }

  /* ensure canvas fits inside the box */
  .canvas-wrap{ width:100%; display:flex; justify-content:center; align-items:center; }
  @media (max-width:820px){
    .game-card{ grid-template-columns: 1fr; }
    .panel{ order:2; }
  }
</style>
</head>
<body>
  <div class="game-card" role="application" aria-label="Angry Birds Lite game">
    <div class="stage">
      <div class="canvas-wrap">
        <canvas id="game" width="720" height="420"></canvas>
      </div>
    </div>

    <div class="panel">
      <div class="header">
        <div>
          <div class="title">Angry Birds — Lite</div>
          <div class="muted">Drag, aim, and destroy the blocks!</div>
        </div>
        <div style="text-align:right;">
          <div class="muted" style="font-size:12px">Score</div>
          <div id="score" style="font-weight:800;font-size:20px">0</div>
        </div>
      </div>

      <div class="stat"><div>Birds left</div><div id="birds-left">5</div></div>
      <div class="stat"><div>Shots used</div><div id="shots-used">0</div></div>

      <div class="controls">
        <div class="hint">Tip: drag the bird back from the slingshot, release to launch. Touch supported.</div>
        <div style="display:flex;gap:8px;">
          <button id="reset">Reset Level</button>
          <button id="next-level" class="secondary">Next Level</button>
        </div>
      </div>

      <div class="footer">Made for fun — lightweight physics, no external libraries.</div>
    </div>
  </div>

<script>
/*
  Angry Birds Lite
  - Simple physics integrator (Euler)
  - Circle projectile (bird), rect blocks (breakable)
  - Drag to set launch vector from slingshot
  - Touch support included
  - Single-file and self-contained
*/

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI nodes
  const scoreEl = document.getElementById('score');
  const birdsLeftEl = document.getElementById('birds-left');
  const shotsUsedEl = document.getElementById('shots-used');
  const resetBtn = document.getElementById('reset');
  const nextBtn = document.getElementById('next-level');

  // Game variables
  const gravity = 900; // px/s^2
  const dt = 1/60;
  let score = 0;
  let birdsLeft = 5;
  let shotsUsed = 0;

  // Slingshot origin
  const sling = { x: 120, y: H - 110 };

  let mouse = { x:0, y:0, down:false };

  // Bird template
  const birdRadius = 16;
  let currentBird = null; // object when loaded on sling
  let birdsQueue = [];

  // Blocks array
  let blocks = [];

  // Stage ground
  const groundY = H - 40;

  // Level definitions (simple)
  const levels = [
    // Level 0
    [
      {x:520,y:groundY-24,w:40,h:48,health:100},
      {x:570,y:groundY-24,w:40,h:48,health:100},
      {x:545,y:groundY-76,w:120,h:24,health:140},
      {x:640,y:groundY-24,w:36,h:36,health:100},
      {x:680,y:groundY-24,w:36,h:36,health:100},
      {x:660,y:groundY-60,w:120,h:24,health:150}
    ],
    // Level 1 (different arrangement)
    [
      {x:520,y:groundY-24,w:30,h:54,health:90},
      {x:560,y:groundY-24,w:30,h:54,health:90},
      {x:540,y:groundY-80,w:130,h:20,health:160},
      {x:620,y:groundY-24,w:40,h:40,health:110},
      {x:660,y:groundY-24,w:40,h:40,health:110},
      {x:640,y:groundY-68,w:120,h:24,health:150}
    ]
  ];
  let currentLevel = 0;

  // Utility functions
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  // Initialize a bird
  function makeBird(){
    return {
      x: sling.x - 6,
      y: sling.y - 6,
      r: birdRadius,
      vx: 0,
      vy: 0,
      launched: false,
      stuckToSling: true, // until dragged/released
      alive: true
    };
  }

  // Load birds queue based on birdsLeft
  function refillBirds(){
    birdsQueue = [];
    for(let i=0;i<birdsLeft;i++) birdsQueue.push(makeBird());
    currentBird = birdsQueue.shift() || null;
  }

  // Reset level or initialize
  function loadLevel(idx){
    currentLevel = idx % levels.length;
    blocks = JSON.parse(JSON.stringify(levels[currentLevel])); // deep copy
    score = 0;
    shotsUsed = 0;
    birdsLeft = 5;
    refillBirds();
    updateUI();
  }

  // UI
  function updateUI(){
    scoreEl.textContent = score;
    birdsLeftEl.textContent = birdsLeft;
    shotsUsedEl.textContent = shotsUsed;
  }

  // Input handling (mouse & touch)
  function getCanvasPos(e){
    const rect = canvas.getBoundingClientRect();
    if(e.touches && e.touches[0]) e = e.touches[0];
    return { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) };
  }
  canvas.addEventListener('mousedown', (e) => {
    const p = getCanvasPos(e);
    mouse.down = true; mouse.x = p.x; mouse.y = p.y;
    if(currentBird && pointInCircle(p.x,p.y,currentBird)){
      currentBird.stuckToSling = true;
    }
  });
  window.addEventListener('mousemove', (e) => {
    const p = getCanvasPos(e);
    mouse.x = p.x; mouse.y = p.y;
    if(mouse.down && currentBird && currentBird.stuckToSling){
      // drag: limit pull distance
      const dx = p.x - sling.x, dy = p.y - sling.y;
      const maxPull = 110;
      const mag = Math.hypot(dx,dy);
      const clampMag = Math.min(mag, maxPull);
      const nx = sling.x + dx / (mag || 1) * clampMag;
      const ny = sling.y + dy / (mag || 1) * clampMag;
      currentBird.x = nx; currentBird.y = ny;
    }
  });
  window.addEventListener('mouseup', (e) => {
    const p = getCanvasPos(e);
    mouse.down = false;
    if(currentBird && currentBird.stuckToSling){
      // Launch
      const dx = sling.x - currentBird.x;
      const dy = sling.y - currentBird.y;
      const powerFactor = 5.4; // tune power
      currentBird.vx = dx * powerFactor;
      currentBird.vy = dy * powerFactor;
      currentBird.launched = true;
      currentBird.stuckToSling = false;
      shotsUsed++;
      birdsLeft--;
      updateUI();
    }
  });

  // touch events
  canvas.addEventListener('touchstart', (e) => { e.preventDefault(); const p=getCanvasPos(e); mouse.down=true; mouse.x=p.x; mouse.y=p.y; if(currentBird && pointInCircle(p.x,p.y,currentBird)) currentBird.stuckToSling = true; }, { passive:false });
  canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const p = getCanvasPos(e); mouse.x = p.x; mouse.y = p.y; if(mouse.down && currentBird && currentBird.stuckToSling){ const dx = p.x - sling.x, dy = p.y - sling.y; const maxPull = 110; const mag = Math.hypot(dx,dy); const clampMag = Math.min(mag, maxPull); const nx = sling.x + dx / (mag || 1) * clampMag; const ny = sling.y + dy / (mag || 1) * clampMag; currentBird.x = nx; currentBird.y = ny; } }, { passive:false });
  canvas.addEventListener('touchend', (e) => { e.preventDefault(); mouse.down=false; if(currentBird && currentBird.stuckToSling){ const dx = sling.x - currentBird.x; const dy = sling.y - currentBird.y; const powerFactor = 5.4; currentBird.vx = dx * powerFactor; currentBird.vy = dy * powerFactor; currentBird.launched = true; currentBird.stuckToSling = false; shotsUsed++; birdsLeft--; updateUI(); } }, { passive:false });

  function pointInCircle(px,py,c){
    return Math.hypot(px - c.x, py - c.y) <= c.r + 6;
  }

  // Physics helpers: circle-rect collision
  function circleRectCollision(circle, rect){
    // rect: {x,y,w,h} with x,y center? We'll treat x,y as center
    const rx = rect.x, ry = rect.y, rw = rect.w, rh = rect.h;
    // Find nearest point from circle center to rectangle
    const halfW = rw/2, halfH = rh/2;
    const nearestX = clamp(circle.x, rx-halfW, rx+halfW);
    const nearestY = clamp(circle.y, ry-halfH, ry+halfH);
    const dx = circle.x - nearestX;
    const dy = circle.y - nearestY;
    const dist2 = dx*dx + dy*dy;
    return { collided: dist2 <= circle.r*circle.r, nx: dx, ny: dy, dist2, nearestX, nearestY };
  }

  // Main update loop
  function step(){
    // integrate bird if exists
    if(currentBird && currentBird.alive){
      if(currentBird.launched){
        currentBird.vy += gravity * dt;
        currentBird.x += currentBird.vx * dt;
        currentBird.y += currentBird.vy * dt;

        // simple ground collision & friction
        if(currentBird.y + currentBird.r > groundY){
          currentBird.y = groundY - currentBird.r;
          // bounce damping
          currentBird.vy *= -0.35;
          currentBird.vx *= 0.7;
          // if speed small, settle
          if(Math.hypot(currentBird.vx, currentBird.vy) < 30){
            currentBird.vx = 0; currentBird.vy = 0;
          }
        }
        // out of bounds -> remove bird (allow next)
        if(currentBird.x < -80 || currentBird.x > W+80 || currentBird.y > H+80){
          currentBird.alive = false;
          setTimeout(nextBird, 350);
        }

        // collisions with blocks
        for(let i=0;i<blocks.length;i++){
          const b = blocks[i];
          // treat b.x,b.y as center
          const res = circleRectCollision(currentBird, b);
          if(res.collided){
            // simple impulse: apply bird reflection and reduce health by impact speed
            const speed = Math.hypot(currentBird.vx, currentBird.vy);
            // compute basic normal
            let nx = res.nx, ny = res.ny;
            const mag = Math.hypot(nx,ny) || 1;
            nx /= mag; ny /= mag;
            // reflect velocity
            const dot = currentBird.vx*nx + currentBird.vy*ny;
            currentBird.vx = currentBird.vx - 1.9 * dot * nx;
            currentBird.vy = currentBird.vy - 1.9 * dot * ny;
            // move circle out of penetration a bit
            const overlap = currentBird.r - Math.sqrt(res.dist2) + 0.5;
            currentBird.x += nx * overlap;
            currentBird.y += ny * overlap;

            // damage algorithm: proportional to impact speed
            const dmg = Math.round(speed * 6 + Math.random()*10);
            b.health -= dmg;
            score += Math.max(0, Math.floor(dmg/10));
            // small visual nudge to block (we'll shift its center to give illusion)
            b.x += nx * Math.min(8, dmg/12);
            b.y += ny * Math.min(8, dmg/12);

            // if block destroyed, award bonus and remove
            if(b.health <= 0){
              score += 50;
              // remove with small particle-ish effect (we'll mark and remove)
              blocks.splice(i,1);
              i--;
            }
            updateUI();
          }
        }

        // if bird has basically stopped after launch, allow next bird
        if(currentBird.launched && Math.hypot(currentBird.vx, currentBird.vy) < 6 && Math.abs(currentBird.y + currentBird.r - groundY) < 1){
          currentBird.alive = false;
          setTimeout(nextBird, 500);
        }
      } else {
        // bird stuck on sling (not launched): slowly follow sling if not being dragged
        if(!mouse.down && currentBird.stuckToSling){
          currentBird.x = sling.x - 6;
          currentBird.y = sling.y - 6;
        }
      }
    } else if(!currentBird && birdsQueue.length>0){
      currentBird = birdsQueue.shift();
    }

    // end condition: win if no blocks remain
    if(blocks.length === 0){
      // win: reveal next level button highlight (already present)
    }

    // draw
    draw();

    requestAnimationFrame(step);
  }

  // Move to next bird
  function nextBird(){
    if(birdsQueue.length>0){
      currentBird = birdsQueue.shift();
    } else {
      currentBird = null;
      // no birds left -> check remaining blocks
      if(blocks.length > 0){
        // level failed: still allow user to reset or refill birds (we simply refill one)
        // we won't auto-reset; show birdsLeft zero in UI
      } else {
        // cleared level; let next-level button handle progression
      }
    }
    updateUI();
  }

  // draw functions
  function draw(){
    ctx.clearRect(0,0,W,H);

    // sky gradient (already via canvas bg, but we'll add soft clouds)
    // draw sun/ornaments
    ctx.save();

    // ground
    ctx.fillStyle = "#6BB56F";
    ctx.fillRect(0, groundY, W, H-groundY);

    // draw slingshot base
    drawSlingshot();

    // draw blocks
    blocks.forEach(b => {
      drawBlock(b);
    });

    // draw bird (either current or launched)
    if(currentBird && currentBird.alive){
      drawBird(currentBird);
    }

    // draw UI on canvas (score etc) optionally
    ctx.restore();
  }

  function drawSlingshot(){
    // base
    ctx.save();
    ctx.translate(sling.x, sling.y);
    // posts
    ctx.fillStyle = '#5b3a29';
    ctx.fillRect(-10,0,8,60);
    ctx.fillRect(12,0,8,60);

    // band: only if bird exists and not launched
    if(currentBird && currentBird.stuckToSling){
      ctx.beginPath();
      ctx.moveTo(-6,6);
      ctx.quadraticCurveTo((currentBird.x - sling.x)/2, (currentBird.y - sling.y)/2 + 6, currentBird.x - sling.x + 6, currentBird.y - sling.y + 6);
      ctx.lineWidth = 8;
      ctx.strokeStyle = "rgba(70,20,20,0.85)";
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawBird(b){
    ctx.save();
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fillStyle = '#f23b3b';
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#7a0000';
    ctx.stroke();

    // beak
    ctx.fillStyle = '#ffbd4a';
    ctx.beginPath();
    ctx.moveTo(b.x + b.r*0.7, b.y);
    ctx.lineTo(b.x + b.r*1.05, b.y - 6);
    ctx.lineTo(b.x + b.r*1.05, b.y + 6);
    ctx.closePath();
    ctx.fill();

    // eye
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(b.x - 6, b.y - 7, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(b.x - 5, b.y - 6, 2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawBlock(b){
    ctx.save();
    // health-based color
    const pct = clamp(b.health / 160, 0, 1);
    // from greenish to dark wood:
    const r = Math.round(200 * (1-pct) + 100 * pct);
    const g = Math.round(150 * (1-pct) + 90 * pct);
    const color = `rgb(${r},${g},${80})`;
    ctx.fillStyle = color;
    ctx.translate(b.x, b.y);
    ctx.fillRect(-b.w/2, -b.h/2, b.w, b.h);

    // health bar
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(-b.w/2, -b.h/2 - 8, b.w, 6);
    ctx.fillStyle = 'lime';
    const healthPct = clamp(b.health / 160, 0, 1);
    ctx.fillRect(-b.w/2, -b.h/2 - 8, b.w * healthPct, 6);

    ctx.restore();

    // small shadow
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.beginPath();
    ctx.ellipse(b.x, b.y + b.h/2 + 6, b.w*0.5, 6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Buttons
  resetBtn.addEventListener('click', () => {
    loadLevel(currentLevel);
  });
  nextBtn.addEventListener('click', () => {
    loadLevel(currentLevel + 1);
  });

  // Initial placement: convert level blocks to include center x/y
  function prepareLevelCopy(levelBlocks){
    // each block currently stored with x,y as center
    return levelBlocks.map(b => ({
      x: b.x,
      y: b.y,
      w: b.w,
      h: b.h,
      health: b.health
    }));
  }

  // On load, center anchor positions; we already defined levels with x,y as centers
  loadLevel(0);

  // small helper: populate birds queue on initial load and after resets
  refillBirds();

  // start loop
  requestAnimationFrame(step);

  // Keyboard shortcuts for convenience
  window.addEventListener('keydown', (e) => {
    if(e.key === 'r') loadLevel(currentLevel);
    if(e.key === 'n') loadLevel(currentLevel + 1);
  });

})();
</script>
</body>
</html>
